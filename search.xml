<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>gcc,pwndbg,tmux的一些基本命令</title>
      <link href="/2023/01/22/gcc-pwndbg-tmux%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/01/22/gcc-pwndbg-tmux%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="gcc的一些基本命令">gcc的一些基本命令</h1><h2 id="gcc-test-c">gcc test.c</h2><p>将test.c预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为a.out。</p><h2 id="gcc-test-c-o-name">gcc test.c -o &lt;name&gt;</h2><p>将test.c预处理、汇编、编译并链接形成可执行文件test（文件名为test，&lt;name&gt;=‘test’）。-o选项用来指定输出文件的文件名。(该命令中o为小写英文字母o)</p><h2 id="gcc-test-c-o3">gcc test.c -O3</h2><p>使用编译优化级别1编译程序。级别为1~3(-O1,-O2,-O3)，级别越大优化效果越好，但编译时间越长。（该命令中O为大写英文字母O）</p><p>输出文件的文件名默认为a.out，可以结合-o &lt;name&gt;输出自己想要的文件名。</p><p>级别越高gcc会自动删除一些无用（不可能发生的代码）</p><h2 id="使用gcc编译的过程">使用gcc编译的过程</h2><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/755863d39bfa155b10f0d7a245bd4987.png" alt="755863d39bfa155b10f0d7a245bd4987"></p><p>前面的指令都是直接一步到位，直接形成可执行程序。根据这个编译过程，gcc提供了另一些命令选项来一步一步进行这些过程：</p><h3 id="gcc-e-test-c-o-test-i">gcc -E test.c -o test.i</h3><p>将test.c文件预处理生成名为test.i的文件（此时还不可以执行）。此过程中预处理器执行宏替换、条件编译以及包含指定的文件(include xxx)。</p><h3 id="gcc-s-test-i">gcc -S test.i</h3><p>汇编文件，生成test.s，由预处理得到的源代码文件，进行机器翻译产出。（可以用‘cat test.s |less’命令试着去读读，反正做题都是可执行文件反汇编，汇编一定要会看（俺尽量在看懂））</p><h3 id="gcc-c-test-s">gcc -c test.s</h3><p>将汇编输出文件test.s编译输出test.o文件。&lt;name&gt;.o文件：可重定位目标文件（机器码文件），由汇编文件经过汇编操作生成，该文件不可直接执行。</p><h3 id="gcc-test-o">gcc test.o</h3><p>将编译输出文件test.o链接成最终可执行文件默认a.out（可以用-o来指定输出名字）。&lt;name&gt;(xxx.out)二进制可执行目标文件（也是一个目标文件），由机器码文件进一步链接生成。这一步中，各种符号引用和符号定义转换成为可执行文件中的合适信息，通常是虚拟地址。</p><h2 id="补充">补充</h2><p><font size='5'>同一段代码不同版本的gcc所编译出来的可执行文件不一定相同</font></p><p>以下面一段代码为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file name = question.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> sh[]=<span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">init_func</span><span class="params">()</span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">char</span> *cmd)</span>&#123;</span><br><span class="line">system(cmd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">8</span>] = &#123;&#125;;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">8</span>] = &#123;&#125;;</span><br><span class="line">    <span class="comment">//char a[1] = &#123;&#x27;b&#x27;&#125;;</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;input:&quot;</span>);</span><br><span class="line">gets(a);  </span><br><span class="line"><span class="built_in">printf</span>(a);</span><br><span class="line"><span class="keyword">if</span>(b[<span class="number">0</span>]==<span class="string">&#x27;a&#x27;</span>)&#123; </span><br><span class="line">func(sh);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用gcc-5.4.0编译question.c</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E5%9B%BE%E7%89%8720230122213653.png" alt="QQ图片20230122213653"></p><p>所生成的可执行文件经IDA Pro处理后的伪C代码如图：</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230122214846.png" alt="QQ截图20230122214846"></p><p>可以看到变量format和v5在内存中相差<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>20</mn><mo>−</mo><mn>0</mn><mi>x</mi><mn>10</mn><mo>=</mo><mn>0</mn><mi>x</mi><mn>10</mn><mo stretchy="false">(</mo><mi>D</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>l</mi><mo>:</mo><mn>16</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">0x20-0x10=0x10(Decimal:16)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">20</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">10</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">10</span><span class="mopen">(</span><span class="mord mathnormal">Dec</span><span class="mord mathnormal">ima</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">16</span><span class="mclose">)</span></span></span></span>个字节此题该种编译方式最粗暴的的脚本为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p =process(<span class="string">&quot;./gcc-5.4.0&quot;</span>)  </span><br><span class="line"><span class="comment">#file name=gcc-5.4.0</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x11</span></span><br><span class="line"><span class="comment">#多一个字符&#x27;a&#x27;,覆盖v5为a</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>而当用gcc-12.2.0编译该代码</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230122221127.png" alt="QQ截图20230122221127"></p><p>将产生的gcc-12.2.0文件经过IDA Pro处理,产生的伪C代码乍一看根本没有v5这一个变量：</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230122221850.png" alt="QQ截图20230122221850"></p><p>但是打开gdb，发现反汇编中仍然存在另一个变量的第一个字节与0x61进行比较：</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230122222435.png" alt="QQ截图20230122222435"></p><p>但是发现，我们进行比较的变量在rbp-0x10，但是需要我们输入的变量地址在rbp-0x8</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/rbp1.png" alt="rbp1"></p><p>根据这张图（如果俺画的没有错的话），单纯靠输入多少个‘a’都不可能覆盖到rbp-0x10，从而获取到shell</p><h1 id="gdb-使用pwndbg-的一些基本命令">gdb（使用pwndbg）的一些基本命令</h1><blockquote><p>参考链接：<a href="https://blog.csdn.net/Breeze_CAT/article/details/103789233">https://blog.csdn.net/Breeze_CAT/article/details/103789233</a></p></blockquote><h2 id="i-info">i (info)</h2><h3 id="i-r">i r</h3><p>info registers 查看各个寄存器当前的值</p><p>例：</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230123120605.png" alt="QQ截图20230123120605"></p><h3 id="i-b">i b</h3><p>info breakpoints 查看各个断点的信息</p><p>例：</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230123120712.png" alt="QQ截图20230123120712"></p><h3 id="i-func">i func</h3><p>info func 查看各个函数的信息(一般会超级超级多，建议直接用IDA Pro代替这个指令，就不放图了)</p><h2 id="show">show</h2><p>how //和info类似，但是查看调试器的基本信息，如：</p><blockquote><p>show args //查看参数</p></blockquote><h2 id="backtrace">backtrace</h2><p>查看调用栈</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230123123821.png" alt="QQ截图20230123123821"></p><h2 id="q">q</h2><p>退出gdb，没啥好说的（quit）</p><h2 id="s-si">s/si</h2><p>s 单步步入，遇到调用跟进函数中，相当于step into，源码层面的一步</p><p>si 同s，汇编层面的一步</p><h2 id="fin">fin</h2><p>finish 跳出当前函数，当用s/si误入一个函数时，可以用这个指令跳出该函数（例如误用s/si进入gets函数，输入fin即可以返回main函数，假设由main函数进入gets函数）</p><h2 id="n-ni">n/ni</h2><p>n 单步步过，遇到调用不跟进，相当于step over，源码层面的一步</p><p>ni 同n汇编层面的一步</p><h2 id="c">c</h2><ul><li>c continue，继续执行到断点，没断点就一直执行下去</li></ul><h2 id="b-常">b（常）</h2><ul><li><p>b*(0x123456) //给0x123456地址处的指令下断点</p></li><li><p>b *$ rebase(0x123456) //$rebase 在调试开PIE的程序的时候可以直接加上程序的随机地址</p></li><li><p>b fun_name //给函数fun_name下断点，目标文件要保留符号才行</p><ul><li>b file_name:fun_name</li></ul></li><li><p>b file_name:15 //给file_name的15行下断点，要有源码才行</p><ul><li>b 15</li></ul></li><li><p>b +0x10 //在程序当前停住的位置下0x10的位置下断点，同样可以-0x10，就是前0x10</p></li><li><p>break fun if $rdi==5 //条件断点，rdi值为5的时候才断</p></li></ul><h2 id="删除-禁用断点">删除/禁用断点</h2><ul><li><p>使用info break(简写: i b)来查看断点编号</p></li><li><p>delete 5 //删除5号断点，直接delete不接数字删除所有</p></li><li><p>disable 5 //禁用5号断点</p></li><li><p>enable 5 //启用5号断点</p></li><li><p>clear //清除下面的所有断点</p></li></ul><h2 id="x-常">x（常）</h2><p>查看内存指令x：<br>x /nuf 0x123456 //常用，x指令的格式是：x空格/nfu，nfu代表三个参数</p><ul><li><p>n代表显示几个单元（而不是显示几个字节，后面的u表示一个单元多少个字节），放在’/'后面</p></li><li><p>u代表一个单元几个字节，b(一个字节)，h(俩字节)，w(四字节)，g(八字节),或者直接使用十进制数字代表几个字节</p></li><li><p>f代表显示数据的格式，f和u的顺序可以互换，也可以只有一个或者不带n，用的时候很灵活</p><blockquote><p>x 按十六进制格式显示变量。<br>d 按十进制格式显示变量。<br>u 按十六进制格式显示无符号整型。<br>o 按八进制格式显示变量。<br>t 按二进制格式显示变量。<br>a 按十六进制格式显示变量。<br>c 按字符格式显示变量。<br>f 按浮点数格式显示变量。<br>s 按字符串显示。<br>b 按字符显示。<br>i 显示汇编指令。</p></blockquote><p>例如：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x /10gx 0x123456 //从0x123456开始每个单元八个字节，十六进制显示是个单元的数据</span><br><span class="line">x /10xd $rdi //从rdi指向的地址向后打印10个单元，每个单元4字节的十进制数</span><br><span class="line">x /10i 0x123456 //从0x123456处向后显示十条汇编指令</span><br></pre></td></tr></table></figure><h2 id="p-常">p(常)</h2><ul><li>p fun_name //打印fun_name的地址，需要保留符号</li><li>p 0x10-0x08 //计算0x10-0x08的结果</li><li>p &amp;a //查看变量a的地址</li><li>p *(0x123456) //查看0x123456地址的值，注意和x指令的区别，x指令查看地址的值不用星号</li><li>p $rdi //显示rdi寄存器的值，注意和x的区别，这只是显示rdi的值，而不是rdi指向的值<ul><li>p *($rdi) //显示rdi指向的值</li></ul></li></ul><h2 id="disass-常">disass（常）</h2><p>反汇编指令</p><ul><li>disass 0x123456 //显示0x123456前后的汇编指令</li><li>disass $rip //显示rip指向的地址后的汇编指令</li><li>disass func_name //显示func_name后的汇编指令<ul><li>disass main：</li><li><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230123132356.png" alt="QQ截图20230123132356"></li></ul></li></ul><h2 id="set">set</h2><ul><li>set $rdi=0x10 //把rdi寄存器的值变为0x10</li><li>set *(0x123456)=0x10 //0x123456地址的值变为0x10，注意带星号</li><li>set args “abc” “def” “gh“//给参数123赋值</li><li>set args “python -c ‘print “1234\x7f\xde”’” //使用python给参数赋值不可见字符</li></ul><h2 id="cycl-num">cycl &lt;num&gt;</h2><p>生成指定数目的溢出字符串</p><h2 id="查找">查找</h2><ul><li>search rdi //从当前位置向后查包含rdi的指令，返回若干</li><li>search -h //查看search帮助，我也不太长用这个指令</li><li>find “hello” //查找hello字符串</li><li>ropgadget //查找ropgadget</li></ul><h1 id="tmux的一些基本指令-分屏调试">tmux的一些基本指令（分屏调试）</h1><blockquote><p>参考链接：<a href="https://blog.csdn.net/qq_38156104/article/details/125093656">https://blog.csdn.net/qq_38156104/article/details/125093656</a></p></blockquote><p>使用tmux应该先在终端输入tmux</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230123133843.png" alt="QQ截图20230123133843"></p><p>该命令会启动 Tmux 窗口，底部有一个状态栏。状态栏的左侧是窗口信息（编号和名称），右侧是系统信息。</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230123133958.png" alt="QQ截图20230123133958"></p><p>按下<code>Ctrl+d</code>或者显式输入<code>exit</code>命令，就可以退出 Tmux 窗口。</p><blockquote><p>$ exit</p></blockquote><h2 id="前缀键">前缀键</h2><p>Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是Ctrl+b，即先按下Ctrl+b，快捷键才会生效。</p><p>举例来说，帮助命令的快捷键是Ctrl+b ?。它的用法是，在 Tmux 窗口中，先按下Ctrl+b，再按下?，就会显示帮助信息。然后，按下 ESC 键或q键，就可以退出帮助。</p><h2 id="窗格管理快捷键">窗格管理快捷键</h2><blockquote><p>Ctrl+b %：划分左右两个窗格。<br>Ctrl+b &quot;：划分上下两个窗格。<br>Ctrl+b <arrow key>：光标切换到其他窗格。<arrow key>是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键↓。<br>Ctrl+b ;：光标切换到上一个窗格。<br>Ctrl+b o：光标切换到下一个窗格。<br>Ctrl+b {：当前窗格与上一个窗格交换位置。<br>Ctrl+b }：当前窗格与下一个窗格交换位置。<br>Ctrl+b Ctrl+o：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。<br>Ctrl+b Alt+o：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。<br>Ctrl+b x：关闭当前窗格。<br>Ctrl+b !：将当前窗格拆分为一个独立窗口。<br>Ctrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。<br>Ctrl+b Ctrl+&lt;arrow key&gt;：按箭头方向调整窗格大小。<br>Ctrl+b q：显示窗格编号。</p></blockquote><h2 id="窗口快捷键">窗口快捷键</h2><blockquote><p>Ctrl+b c：创建一个新窗口，状态栏会显示多个窗口的信息。<br>Ctrl+b p：切换到上一个窗口（按照状态栏上的顺序）。<br>Ctrl+b n：切换到下一个窗口。<br>Ctrl+b &lt;number&gt;：切换到指定编号的窗口，其中的&lt;number&gt;是状态栏上的窗口编号。<br>Ctrl+b w：从列表中选择窗口。<br>Ctrl+b ,：窗口重命名。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shellcode</title>
      <link href="/2023/01/15/shellcode/"/>
      <url>/2023/01/15/shellcode/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是shellcode">什么是shellcode</h2><ul><li><p>shellcode通常是软件漏洞利用过程中使用一小段机器代码</p></li><li><p>作用：</p></li><li><p>1.启动shell，进行交互</p></li><li><p>2.打开服务器端口等待连接</p></li><li><p>3.反向连接端口</p></li><li><p>4.。。。</p></li></ul><h2 id="shellcode编写">shellcode编写</h2><p>下面是简单的shell程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -m32 -0 shell shell.c </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">( )</span></span><br><span class="line">&#123;    </span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn笔记(一)</title>
      <link href="/2023/01/05/pwn%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
      <url>/2023/01/05/pwn%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>exploit：</p><blockquote><p>用于攻击的脚本与方案</p></blockquote></blockquote><blockquote><p>payload:</p><blockquote><p>攻击载荷，是让目的进程被劫持控制流的数据</p></blockquote></blockquote><blockquote><p>shellcode:</p><blockquote><p>调用攻击目标的shell的代码</p></blockquote></blockquote><h1 id="程序的编译与链接">程序的编译与链接</h1><h2 id="从c源代码到可执行文件的生成过程：">从C源代码到可执行文件的生成过程：</h2><ol><li><p>编译：<br>由C语言代码生成汇编代码</p></li><li><p>汇编：</p></li></ol><p>​    由汇编代码生成机器码</p><ol start="3"><li><p>链接</p><p>将多个机器码的目标文件链接成一个可执行的文件</p></li></ol><p>以下是用”gcc &lt;文件名&gt;”这个命令所发生的一系列过程:</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230103200525.png" alt=""></p><p>整个过程：</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230103200844.png" alt=""></p><h2 id="什么是可执行文件？">什么是可执行文件？</h2><p>一. 广义：文件中的数据是可执行代码的文件(只要能够运行)</p><p>​.out、.exe、.sh、.py</p><p>二. 狭义：文件中的数据是机器码的文件</p><p>​.out、.exe、.dll、.so</p><p>可执行文件的分类：</p><table><thead><tr><th></th><th>Windows: PE(Portable Executable)</th><th>Linux: ELF (Exexutable and Linkable Format)</th></tr></thead><tbody><tr><td>可执行程序</td><td>.exe</td><td>.out</td></tr><tr><td>动态链接库</td><td>.dll</td><td>.so</td></tr><tr><td>静态链接库</td><td>.lib</td><td>.a</td></tr></tbody></table><table><tr><td bgcolor=PowderBlue><label style="color:blue">"gcc <文件名>" 命令产生的文件目前存放在磁盘中，是ELF文件，当你打开后，该文件会加载到内存中（此时就不叫ELF）</label> </td></tr></table><h2 id="elf文件结构">ELF文件结构</h2><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230103204214.png" alt=""></p><p>ELF：</p><ul><li><p>header</p><ul><li>ELF header：记录整个ELF文件的整个结构分布</li><li>Program Header Table: 主要记录一些段的信息</li></ul></li><li><p>sections</p><ul><li>Code <s>后面会是Code段</s> ： 记录不同的机械码的分区，不同的分区有不同的功能，不同的功能被划分成不同的代码节（用户： .text节）</li><li>Data <s>同理后面会是Data段</s> ： 不能被执行，存放数据（got节:记录全局偏移量的地址,Dynamic节：存放动态链接的数据 ）</li><li>Sections’ names: 记录了各个节的节名（字典）</li></ul></li><li><p>Header</p><ul><li>Section Header Table: 包含了描述文件节区的信息，每个节区在表中都有一项，每一项给出诸如节区名称、节区大小这类信息。</li></ul></li></ul><blockquote><p>段：当程序加载到内存中成为进程的时候，进行读、写、执行、权限划分的一个视图</p><p>节：elf文件存放在磁盘中，进行不同功能区域划分的一个视图</p></blockquote><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230103212006.png" alt=""></p><h1 id="程序装载与虚拟内存">程序装载与虚拟内存</h1><table><tr><td bgcolor=PowderBlue><label style="color:blue">CPU访问的是主存中的数据</label> </td></tr></table><p>内存算是主存 磁盘是外存（断电任然可以保存数据）</p><p>程序执行时，要从磁盘中“拷贝”到内存中。变成VM（virtual memory）视图。从磁盘中的 程序文件变成内存中的一个进程对应的虚拟内存区域。</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230103214324.png" alt=""></p><p>Data段： 由具有读，写权限的节（.data、.bss、.got、.plt）转化</p><p>Code段（text段）： 由没有写的权限，只有读或者具有可读可执行的权限的节（.rodata（read only data）、.text、.init、ELF Header）转化</p><p>查看磁盘结构不仅可以使用IDA Pro，在Linux上，可以使用“objdump -s elf”指令查看。</p><h2 id="在linux下：使用-cat-proc-pid-maps-命令：">在Linux下：使用“cat /proc/pid/maps”命令：</h2><blockquote><p>原文链接：<a href="https://blog.csdn.net/unix21/article/details/8450042">https://blog.csdn.net/unix21/article/details/8450042</a></p></blockquote><p>proc/“进程PID”/maps<br>查看进程的虚拟地址空间是如何使用的。<br>该文件有6列，分别为：<br>地址：库在进程里地址范围<br>权限：虚拟内存的权限，r=读，w=写,x=,s=共享,p=私有；<br>偏移量：库在进程里地址范围<br>设备：映像文件的主设备号和次设备号；<br>节点：映像文件的节点号；<br>路径: 映像文件的路径<br>每项都与一个vm_area_struct结构成员对应</p><p>例如以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> sh[]=<span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">init_func</span><span class="params">()</span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">char</span> *cmd)</span>&#123;</span><br><span class="line">        system(cmd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">8</span>] = &#123;&#125;;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">8</span>] = &#123;&#125;;</span><br><span class="line">    <span class="comment">//char a[1] = &#123;&#x27;b&#x27;&#125;;</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;input:&quot;</span>);</span><br><span class="line">        gets(a);</span><br><span class="line">        <span class="built_in">printf</span>(a);</span><br><span class="line">        <span class="keyword">if</span>(b[<span class="number">0</span>]==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">                func(sh);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成文件名为out的文件（gcc test.c -o out）</p><p>执行该文件 ./out</p><p>查看内存进程 <strong>ps au</strong></p><p>143就是我们需要的pid</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230110154845.png" alt="QQ截图20230110154845"></p><p>cat proc/143/maps:</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230110155144.png" alt="QQ截图20230110155144"></p><p>参数 解释<br>address: 0085d000-00872000 虚拟内存区域的起始和终止地址文件所占的地址空间<br>perms:rw-p 权限：r=read, w=write, x=execute, s=shared, p=private(copy on write)<br>offset: 00000000 虚拟内存区域在被映射文件中的偏移量<br>dev: 03:08 文件的主设备号和次设备号<br>inode: 设备的节点号，0表示没有节点与内存相对应<br>name: /lib/ld-2.31.so 被映射文件的文件名<br>各共享库的代码段，存放着二进制可执行的机器指令，是由kernel把该库ELF文件的代码段map到虚存空间；<br>各共享库的数据段，存放着程序执行所需的全局变量，是由kernel把ELF文件的数据段map到虚存空间；<br>用户代码段，存放着二进制形式的可执行的机器指令，是由kernel把ELF文件的代码段map到虚存空间；<br>用户数据段之上是代码段，存放着程序执行所需的全局变量，是由kernel把ELF文件的数据段map到虚存空间；<br>用户数据段之下是堆(heap)，当且仅当malloc调用时存在，是由kernel把匿名内存map到虚存空间，堆则在程序中没有调用malloc的情况下不存在；<br>用户数据段之下是栈(stack)，作为进程的临时数据区，是由kernel把匿名内存map到虚存空间，栈空间的增长方向是从高地址到低地址。</p><p><strong><font size='10'>体现了Linux一切皆文件的说法</font></strong></p><h2 id="补充基础知识">补充基础知识</h2><p><font size='5'>地址以字节编码</font></p><p>1Byte =8bit</p><p><font size="5">常以16进制表示</font></p><p>0x3c=0011 1100</p><p><font size='4'>虚拟内存<font color="red">用户空间</font>每个进程一份</font></p><p><font size='4'>虚拟内存<font color='red'>内核空间</font>所有进程共享一份</font></p><p><font size='4'>虚拟内存mmap段中的<font color='red'>动态链接库</font>仅在物理内存中装载一份</font></p><p><font size='4'>把高位想象成低地址，低位想象成高地址，像这样：</font></p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230114153743.png" alt="QQ截图20230114153743"></p><h1 id="cpu与进程的执行">CPU与进程的执行</h1><h2 id="段和节的具体划分">段和节的具体划分</h2><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230114154419.png" alt="QQ截图20230114154419"></p><p>节： 在磁盘上的可执行文件的一个结构。大多由机器码构成。</p><p>数据段：不是机器码（代码），可能地址或者其他的数据</p><h2 id="c语言代码是怎么变成与段和节的划分的对应关系">c语言代码是怎么变成与段和节的划分的对应关系</h2><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230114155118.png" alt="QQ截图20230114155118"></p><p>glb : 未初始化的全局变量 ——&gt;Bss（不需要占用磁盘空间，但占用内存空间）</p><p>hello world! ：只读不可写不可执行，放在text段，只读数据（可读可写的数据才会放到data段）</p><p>sum函数 : 被编译后成为数据（机器码，代码）放到text段</p><p>t（局部变量）: 放在栈中</p><p>sum(1,2) : 改行也放在栈中</p><p>ptr : 放在栈中，指向堆上开辟的0x100的空间的首地址</p><h2 id="大端序和小端序">大端序和小端序</h2><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230114165725.png" alt="QQ截图20230114165725"></p><p><font size='5'>小端序</font></p><p>低低高高：低位存放在小地址，高位存放在大地址</p><p><font size='5'>大端序</font></p><p>高位存放在低地址，低位存放在大地址</p><h2 id="程序的执行过程">程序的执行过程</h2><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230114170640.png" alt="QQ截图20230114170640"></p><p>PC: 总是保存了当前在内存中代码段中正在执行的地址</p><p><font size="5">amd64寄存器结构</font></p><ul><li>rax: 8 Bytes</li><li>eax: 4 Bytes</li><li>ax : 2 Bytes</li><li>ah : 1 Bytes</li><li>al : 1 Bytes</li></ul><p><font size='5'>部分寄存器功能</font></p><ul><li><p>RIP-pc(program counter)</p><ul><li>存放下一条执行的指令的偏移地址</li></ul></li><li><p>RSP</p><ul><li>存放当前栈帧的栈顶偏移地址</li></ul></li><li><p>RBP</p><ul><li>存放当前栈帧的栈底偏移地址</li></ul></li><li><p>rax</p><ul><li>通用寄存器，存放函数返回值</li></ul></li></ul><h1 id="装载与汇编">装载与汇编</h1><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230115190601.png" alt="QQ截图20230115190601"></p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230115193900.png" alt="QQ截图20230115193900"></p><p>fork() 另启了一个新进程，在这个新进程中使用execve的系统调用，进入内核状态，内核执行kernel mode中的几个函数，新的进程就会进入_start标签，从而进入目标进程的main函数或者__libc_start_main函数。</p><h3 id="汇编">汇编</h3><h5 id="指令格式">指令格式</h5><table><thead><tr><th>Base</th><th>index</th><th>scale</th></tr></thead><tbody><tr><td>0</td><td>2</td><td>4</td></tr></tbody></table><p>偏移地址：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>+</mo><mn>2</mn><mo>∗</mo><mn>4</mn><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">0+2*4 = 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span>。Displacement，位移。假设，位移为0x10。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>+</mo><mn>2</mn><mo>∗</mo><mn>4</mn><mo>+</mo><mn>0</mn><mi>x</mi><mn>10</mn><mo>=</mo><mn>24</mn></mrow><annotation encoding="application/x-tex">0+2*4 + 0x10 = 24</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">10</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">24</span></span></span></span>。偏移(offset)。</p><h5 id="call指令">Call指令</h5><p>push 调用函数后的下一条指令。然后，jmp过去。</p><h5 id="mov指令">MOV指令</h5><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230115193802.png" alt=""></p><p>mov指令，为传送指令。</p><h4 id="两种汇编格式">两种汇编格式</h4><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230115194428.png" alt="QQ截图20230115194428"></p><h5 id="intel汇编格式">intel汇编格式</h5><p>byte ptr。</p><table><thead><tr><th>intel</th><th>at&amp;t</th></tr></thead><tbody><tr><td>mov qword ptr [rsp], 0xffff</td><td>movq $0xffff, (%rsp)</td></tr></tbody></table><p>at&amp;t， Disp(base, index, scale)。</p><p>intel，[base+index*scale]Disp。</p><h5 id="jmp-condition指令">Jmp condition指令</h5><table><thead><tr><th>操作码</th><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>77 <strong>cb</strong></td><td>JA <strong>rel8</strong></td><td>高于（CF=0 且 ZF=0）时短跳转</td></tr><tr><td>73 <strong>cb</strong></td><td>JAE <strong>rel8</strong></td><td>高于或等于 (CF=0) 时短跳转</td></tr><tr><td>72 <strong>cb</strong></td><td>JB <strong>rel8</strong></td><td>低于 (CF=1) 时短跳转</td></tr><tr><td>76 <strong>cb</strong></td><td>JBE <strong>rel8</strong></td><td>低于或等于（CF=1 或  ZF=1）时短跳转</td></tr><tr><td>72 <strong>cb</strong></td><td>JC <strong>rel8</strong></td><td>进位 (CF=1) 时短跳转</td></tr><tr><td>E3 <strong>cb</strong></td><td>JCXZ <strong>rel8</strong></td><td>CX 寄存器为 0 时短跳转</td></tr><tr><td>E3 <strong>cb</strong></td><td>JECXZ <strong>rel8</strong></td><td>ECX 寄存器为 0 时短跳转</td></tr><tr><td>74 <strong>cb</strong></td><td>JE <strong>rel8</strong></td><td>等于 (ZF=1) 时短跳转</td></tr><tr><td>7F <strong>cb</strong></td><td>JG <strong>rel8</strong></td><td>大于（ZF=0 且 SF=OF）时短跳转</td></tr><tr><td>7D <strong>cb</strong></td><td>JGE <strong>rel8</strong></td><td>大于或等于 (SF=OF) 时短跳转</td></tr><tr><td>7C <strong>cb</strong></td><td>JL <strong>rel8</strong></td><td>小于 (SF&lt;&gt;OF)  时短跳转</td></tr><tr><td>7E <strong>cb</strong></td><td>JLE <strong>rel8</strong></td><td>小于或等于（ZF=1 或 SF&lt;&gt;OF）时短跳转</td></tr></tbody></table><h3 id="数学基础">数学基础</h3><h5 id="加法群">加法群</h5><p>模2加。异或。</p><h5 id="z-3"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Z</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">Z_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></h5><p>mod 3。0， 1， 2。问题：2的逆，是多少。-2？不对，因为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Z</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">Z_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>里面，没有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">2</span></span></span></span>。所以，2的逆，为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-2 + 3 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。每3，一个轮回。</p><p>思考一下，二进制位的取反加一，其实是什么？就是“加一个轮回”。</p><p>例子：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">2^2 = 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span>。0b00, 0b01, 0b10, 0b11。问，0b01，的逆是多少。先进行取反，0b10，就是加了“<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">4-1 = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>“，所以，还要加一，才是一个轮回。</p><h5 id="溢出的问题">溢出的问题</h5><p>正数加正数，不可能等于一个负数，如果出现了，就是溢出。负数加负数，也不可能等于一个正数，如果出现了，就是溢出。溢出的概念，只发生在有符号数。无符号数，是没有溢出这个概念的。</p><p>于是，这就涉及到了，有符号数的大小判断。因为CMP，作的是目的操作数，减去源操作数的一个减法运算。试想一下，如果目的操作数，是一个正数，而源操作数，是一个负数。那么，正数减去负数，就相当于正数加正数。</p><p>有符号数，正数的最高位，是0。但是，两个正数相加，最高位，可能溢出，变成了1。这不就出现了负数了吗。从，目的操作数，与源操作数的符号(正负)，可知，目的操作数为正数，肯定大于负数。结果为，”&gt;“，大于。</p><p>发生了溢出之后，OF=1。但SF=1(负数)。此时，OF=SF，所以是大于。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>留言板</title>
      <link href="/comment/index.html"/>
      <url>/comment/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="留什么言-发qq或者微信不好吗">留什么言，发QQ或者微信不好吗</h1>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="计算机类在读-剩下的后面再写">计算机类在读，，剩下的后面再写</h1>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-DXmCQbwY" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="3166847468" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="400px" data-preload="none" data-theme="#ad7a86"    ></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>相册</title>
      <link href="/photos/index.html"/>
      <url>/photos/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="这个也是">这个也是</h1>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>影视</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="应该不会写这个地方">应该不会写这个地方</h1><p>如果有，再说</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分享</title>
      <link href="/shuoshuo/index.html"/>
      <url>/shuoshuo/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="还没想好写什么呢">还没想好写什么呢</h1>]]></content>
      
    </entry>
    
    
  
</search>
